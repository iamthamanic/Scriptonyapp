  const handleTrimMove = (e: MouseEvent) => {
    if (!trimingBeat) return;
    
    const deltaX = e.clientX - trimStartXRef.current;
    const deltaSec = deltaX / pxPerSec;
    const newSec = trimStartSecRef.current + deltaSec;
    
    // Get current beat
    const beat = beats.find(b => b.id === trimingBeat.id);
    if (!beat) return;
    
    if (trimingBeat.handle === 'left') {
      // LEFT HANDLE: Resize from start
      const oldEndSec = (beat.pct_to / 100) * duration;
      let clampedStartSec = Math.max(0, Math.min(oldEndSec - MIN_BEAT_DURATION_SEC, newSec));
      let newPctFrom = (clampedStartSec / duration) * 100;
      
      // Find adjacent beat
      const otherBeats = beats
        .filter(b => b.id !== trimingBeat.id)
        .sort((a, b) => a.pct_from - b.pct_from);
      
      const beatsAbove = otherBeats.filter(b => b.pct_to <= newPctFrom);
      const beatAbove = beatsAbove.length > 0 ? beatsAbove[beatsAbove.length - 1] : null;
      
      // SNAP if magnet enabled
      if (beatAbove && beatMagnetEnabled) {
        const distance = Math.abs(newPctFrom - beatAbove.pct_to);
        if (distance < SNAP_THRESHOLD_PERCENT) {
          newPctFrom = beatAbove.pct_to;
        }
      }
      
      // HARD STOP: Prevent overlap
      if (beatAbove && newPctFrom < beatAbove.pct_to) {
        newPctFrom = beatAbove.pct_to;
      }
      
      // Min beat duration
      const maxAllowed = beat.pct_to - (MIN_BEAT_DURATION_SEC / duration * 100);
      newPctFrom = Math.min(newPctFrom, maxAllowed);
      
      setBeats(prev => prev.map(b =>
        b.id === trimingBeat.id ? { ...b, pct_from: newPctFrom } : b
      ));
      
    } else {
      // RIGHT HANDLE: CapCut/DaVinci Magnet (Snapping + Hard Stop, NO pushing)
      const oldStartSec = (beat.pct_from / 100) * duration;
      let clampedEndSec = Math.max(oldStartSec + MIN_BEAT_DURATION_SEC, Math.min(duration, newSec));
      let newPctTo = (clampedEndSec / duration) * 100;
      
      // Find adjacent beat
      const otherBeats = beats
        .filter(b => b.id !== trimingBeat.id)
        .sort((a, b) => a.pct_from - b.pct_from);
      
      const beatsBelow = otherBeats.filter(b => b.pct_from >= beat.pct_to);
      const beatBelow = beatsBelow.length > 0 ? beatsBelow[0] : null;
      
      // CAPCUT MAGNET: Snapping + Hard Stop (NO pushing)
      if (beatBelow) {
        // SNAP if close enough and magnet enabled
        if (beatMagnetEnabled) {
          const distance = Math.abs(newPctTo - beatBelow.pct_from);
          if (distance < SNAP_THRESHOLD_PERCENT) {
            console.log(`[Beat Trim] ðŸ§² SNAP! Distance=${distance.toFixed(2)}%`);
            newPctTo = beatBelow.pct_from;
          }
        }
        
        // HARD STOP: Prevent overlap (always active)
        if (newPctTo > beatBelow.pct_from) {
          console.log(`[Beat Trim] ðŸš« HARD STOP at ${beatBelow.pct_from.toFixed(1)}%`);
          newPctTo = beatBelow.pct_from;
        }
      }
      
      // Min beat duration
      const minAllowed = beat.pct_from + (MIN_BEAT_DURATION_SEC / duration * 100);
      newPctTo = Math.max(newPctTo, minAllowed);
      
      setBeats(prev => prev.map(b =>
        b.id === trimingBeat.id ? { ...b, pct_to: newPctTo } : b
      ));
    }
  };
  
