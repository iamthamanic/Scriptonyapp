/**
 * ðŸŽ¬ FILM DROPDOWN - Hierarchical Structure View
 * 
 * Acts > Sequences > Scenes > Shots (Dropdown/Collapsible View)
 * Minimalistic inline editing with clean collapsed/expanded states
 * Drag & Drop: Within containers + Cross-container
 * Optimistic UI + Performance optimizations
 * 
 * âš¡ PERFORMANCE FIX (2025-11-02):
 * - Removed layout animation from motion.div (conflicts with Collapsible)
 * - Reduced animation complexity for smoother expand/collapse
 * - overflow-hidden on Collapsible prevents layout shift
 */

import { useState, useEffect, useRef, useCallback } from 'react';
import { Plus, Trash2, GripVertical, ChevronDown, ChevronRight, MoreVertical, Copy, Edit, Info } from 'lucide-react';
import { DndProvider, useDrag, useDrop } from 'react-dnd';
import { HTML5Backend } from 'react-dnd-html5-backend';
import { Button } from './ui/button';
import { Input } from './ui/input';
import { Textarea } from './ui/textarea';
import { cn } from './ui/utils';
import { undoManager } from '../lib/undo-manager';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from './ui/dropdown-menu';
import {
  Collapsible,
  CollapsibleContent,
  CollapsibleTrigger,
} from './ui/collapsible';
import { ShotCard } from './ShotCard';
import { TimelineNodeStatsDialog } from './TimelineNodeStatsDialog';
import { useAuth } from '../hooks/useAuth';
import * as ShotsAPI from '../lib/api/shots-api';
import * as TimelineAPI from '../lib/api/timeline-api';
import * as CharactersAPI from '../lib/api/characters-api';
import type { Act, Sequence, Scene, Shot, Character } from '../lib/types';
import { toast } from 'sonner';
import { perfMonitor } from '../lib/performance-monitor';
import { cacheManager } from '../lib/cache-manager';

// Timeline Cache Data Structure
export interface TimelineData {
  acts: Act[];
  sequences: Sequence[];
  scenes: Scene[];
  shots: Shot[];
}

interface FilmDropdownProps {
  projectId: string;
  projectType?: string; // ðŸŽ¯ NEW: Project type for dynamic labels (film/series/book/audio)
  characters?: Character[]; // Optionally pass characters from parent to avoid double-loading
  initialData?: TimelineData; // ðŸš€ PERFORMANCE: Pre-loaded timeline data for instant rendering
  onDataChange?: (data: TimelineData) => void; // Callback to update parent cache
  containerRef?: React.RefObject<HTMLDivElement>; // ðŸŽ¯ Ref for BeatColumn synchronization
  // ðŸŽ¯ Controlled Collapse States for dynamic beat alignment
  expandedActs?: Set<string>;
  expandedSequences?: Set<string>;
  expandedScenes?: Set<string>;
  onExpandedActsChange?: (expanded: Set<string>) => void;
  onExpandedSequencesChange?: (expanded: Set<string>) => void;
  onExpandedScenesChange?: (expanded: Set<string>) => void;
}

// DnD Types
const ItemTypes = {
  ACT: 'act',
  SEQUENCE: 'sequence',
  SCENE: 'scene',
  SHOT: 'shot',
};

// =====================================================
// DROP ZONE (EinfÃ¼gemarke zwischen Items) - volle HÃ¶he!
// =====================================================

interface DropZoneProps {
  type: string;
  index: number;
  onDrop: (draggedItemId: string, targetIndex: number) => void;
  label: string;
  height?: 'act' | 'sequence' | 'scene' | 'shot';
}

function DropZone({ type, index, onDrop, label, height = 'act' }: DropZoneProps) {
  const [{ isOver, canDrop }, drop] = useDrop({
    accept: type,
    drop: (item: { id: string; index: number }) => {
      onDrop(item.id, index);
    },
    collect: (monitor) => ({
      isOver: monitor.isOver(),
      canDrop: monitor.canDrop(),
    }),
  });

  // HÃ¶he basierend auf Item-Typ (eingeklappt)
  const heightClass = {
    act: 'h-20',      // Act Header HÃ¶he
    sequence: 'h-14', // Sequence Header HÃ¶he
    scene: 'h-12',    // Scene Header HÃ¶he
    shot: 'h-24',     // Shot Card HÃ¶he
  }[height];

  const normalHeight = {
    act: 'h-8',       // Basis-HÃ¶he wenn nicht gehovered
    sequence: 'h-6',
    scene: 'h-6',
    shot: 'h-8',
  }[height];

  return (
    <div
      ref={drop}
      className={cn(
        'transition-all duration-100 flex items-center justify-center my-1',
        canDrop ? (isOver ? heightClass : normalHeight) : 'h-1'
      )}
    >
      {canDrop && (
        <div className={cn(
          'w-full h-full rounded-lg flex items-center justify-center transition-all duration-100',
          isOver 
            ? 'border-2 border-dashed border-violet-400 dark:border-violet-500 bg-violet-50/60 dark:bg-violet-900/20'
            : 'border border-dashed border-gray-300/50 dark:border-gray-600/30 bg-transparent'
        )}>
          {isOver && (
            <span className="text-violet-700 dark:text-violet-300 text-sm font-medium">
              â†“ {label} hier einfÃ¼gen
            </span>
          )}
        </div>
      )}
    </div>
  );
}

// =====================================================
// DRAGGABLE ACT CONTAINER (mit Swap-Drop)
// =====================================================

interface DraggableActProps {
  act: Act;
  index: number;
  onSwap: (draggedId: string, targetId: string) => void;
  children: React.ReactNode;
}

function DraggableAct({ act, index, onSwap, children }: DraggableActProps) {
  const [{ isDragging }, drag] = useDrag({
    type: ItemTypes.ACT,
    item: { id: act.id, index },
    collect: (monitor) => ({
      isDragging: monitor.isDragging(),
    }),
  });

  const [{ isOver }, drop] = useDrop({
    accept: ItemTypes.ACT,
    drop: (item: { id: string; index: number }) => {
      if (item.id !== act.id) {
        onSwap(item.id, act.id);
      }
    },
    collect: (monitor) => ({
      isOver: monitor.isOver(),
    }),
  });

  return (
    <div
      ref={(node) => drag(drop(node))}
      className={cn(
        "relative transition-opacity duration-150",
        isDragging && "opacity-40 scale-[0.98]"
      )}
    >
      {isOver && !isDragging && (
        <div className="absolute -inset-0.5 border-2 border-blue-400 dark:border-blue-500 bg-blue-50/20 dark:bg-blue-900/10 rounded-lg pointer-events-none z-10" />
      )}
      
      {children}
    </div>
  );
}

// =====================================================
// DRAGGABLE SEQUENCE CONTAINER (mit Swap-Drop)
// =====================================================

interface DraggableSequenceProps {
  sequence: Sequence;
  index: number;
  onSwap: (draggedId: string, targetId: string) => void;
  children: React.ReactNode;
}

function DraggableSequence({ sequence, index, onSwap, children }: DraggableSequenceProps) {
  const [{ isDragging }, drag] = useDrag({
    type: ItemTypes.SEQUENCE,
    item: { id: sequence.id, index },
    collect: (monitor) => ({
      isDragging: monitor.isDragging(),
    }),
  });

  const [{ isOver }, drop] = useDrop({
    accept: ItemTypes.SEQUENCE,
    drop: (item: { id: string; index: number }) => {
      if (item.id !== sequence.id) {
        onSwap(item.id, sequence.id);
      }
    },
    collect: (monitor) => ({
      isOver: monitor.isOver(),
    }),
  });

  return (
    <div
      ref={(node) => drag(drop(node))}
      className={cn(
        "relative transition-opacity duration-150",
        isDragging && "opacity-40 scale-[0.98]"
      )}
    >
      {isOver && !isDragging && (
        <div className="absolute -inset-0.5 border-2 border-green-400 dark:border-green-500 bg-green-50/20 dark:bg-green-900/10 rounded-lg pointer-events-none z-10" />
      )}
      
      {children}
    </div>
  );
}

// =====================================================
// DRAGGABLE SCENE CONTAINER (mit Swap-Drop)
// =====================================================

interface DraggableSceneProps {
  scene: Scene;
  index: number;
  onSwap: (draggedId: string, targetId: string) => void;
  children: React.ReactNode;
}

function DraggableScene({ scene, index, onSwap, children }: DraggableSceneProps) {
  const [{ isDragging }, drag] = useDrag({
    type: ItemTypes.SCENE,
    item: { id: scene.id, index },
    collect: (monitor) => ({
      isDragging: monitor.isDragging(),
    }),
  });

  const [{ isOver }, drop] = useDrop({
    accept: ItemTypes.SCENE,
    drop: (item: { id: string; index: number }) => {
      if (item.id !== scene.id) {
        onSwap(item.id, scene.id);
      }
    },
    collect: (monitor) => ({
      isOver: monitor.isOver(),
    }),
  });

  return (
    <div
      ref={(node) => drag(drop(node))}
      className={cn(
        "relative transition-opacity duration-150",
        isDragging && "opacity-40 scale-[0.98]"
      )}
    >
      {isOver && !isDragging && (
        <div className="absolute -inset-0.5 border-2 border-orange-400 dark:border-orange-500 bg-orange-50/20 dark:bg-orange-900/10 rounded-lg pointer-events-none z-10" />
      )}
      
      {children}
    </div>
  );
}

// =====================================================
// DRAGGABLE SHOT CONTAINER (mit Swap-Drop)
// =====================================================

interface DraggableShotProps {
  shot: Shot;
  index: number;
  onSwap: (draggedId: string, targetId: string) => void;
  children: React.ReactNode;
}

function DraggableShot({ shot, index, onSwap, children }: DraggableShotProps) {
  const [{ isDragging }, drag] = useDrag({
    type: ItemTypes.SHOT,
    item: { id: shot.id, index },
    collect: (monitor) => ({
      isDragging: monitor.isDragging(),
    }),
  });

  const [{ isOver }, drop] = useDrop({
    accept: ItemTypes.SHOT,
    drop: (item: { id: string; index: number }) => {
      if (item.id !== shot.id) {
        onSwap(item.id, shot.id);
      }
    },
    collect: (monitor) => ({
      isOver: monitor.isOver(),
    }),
  });

  return (
    <div
      ref={(node) => drag(drop(node))}
      className={cn(
        "relative transition-opacity duration-150",
        isDragging && "opacity-40 scale-[0.98]"
      )}
    >
      {isOver && !isDragging && (
        <div className="absolute -inset-0.5 border-2 border-red-400 dark:border-red-500 bg-red-50/20 dark:bg-red-900/10 rounded-lg pointer-events-none z-10" />
      )}
      
      {children}
    </div>
  );
}

// =====================================================
// MAIN COMPONENT
// =====================================================

export function FilmDropdown({ 
  projectId,
  projectType = 'film', // Default to film if not provided
  characters: externalCharacters,
  initialData,
  onDataChange,
  containerRef,
}: FilmDropdownProps) {
  const { getAccessToken } = useAuth();

  // ðŸŽ¯ DYNAMIC LABELS based on project type
  const getLabels = () => {
    if (projectType === 'book') {
      return {
        sequence: 'Kapitel',
        sequences: 'Kapitel',
        addSequence: 'Kapitel hinzufÃ¼gen',
        scene: 'Abschnitt',
        scenes: 'Abschnitte',
        addScene: 'Abschnitt hinzufÃ¼gen',
        shot: 'Shot', // Not used for books
        shots: 'Shots',
        addShot: 'Shot hinzufÃ¼gen',
        showShots: false, // Hide shots for books
      };
    }
    // Default: film/series/audio
    return {
      sequence: 'Sequence',
      sequences: 'Sequences',
      addSequence: 'Sequence hinzufÃ¼gen',
      scene: 'Szene',
      scenes: 'Szenen',
      addScene: 'Szene hinzufÃ¼gen',
      shot: 'Shot',
      shots: 'Shots',
      addShot: 'Shot hinzufÃ¼gen',
      showShots: true,
    };
  };

  const labels = getLabels();

  // State - Initialize with initialData if available for instant rendering ðŸš€
  const [acts, setActs] = useState<Act[]>(initialData?.acts || []);
  const [sequences, setSequences] = useState<Sequence[]>(initialData?.sequences || []);
  const [scenes, setScenes] = useState<Scene[]>(initialData?.scenes || []);
  const [shots, setShots] = useState<Shot[]>(initialData?.shots || []);
  const [loading, setLoading] = useState(!initialData); // No loading if we have initialData!

  // Expand/Collapse State
  const [expandedActs, setExpandedActs] = useState<Set<string>>(new Set());
  const [expandedSequences, setExpandedSequences] = useState<Set<string>>(new Set());
  const [expandedScenes, setExpandedScenes] = useState<Set<string>>(new Set());
  const [expandedShots, setExpandedShots] = useState<Set<string>>(new Set());
  
  // Project Characters for @-mentions
  // Use external characters if provided, otherwise load from API
  const [characters, setCharacters] = useState<Character[]>(externalCharacters || []);

  // Edit State (for inline editing)
  const [editingAct, setEditingAct] = useState<string | null>(null);
  const [editingSequence, setEditingSequence] = useState<string | null>(null);
  const [editingScene, setEditingScene] = useState<string | null>(null);
  const [editValues, setEditValues] = useState<Record<string, { title?: string; description?: string }>>({});

  // Creating State
  const [creating, setCreating] = useState<string | null>(null);
  const [pendingIds, setPendingIds] = useState<Set<string>>(new Set());

  // Info Dialog State
  const [infoDialogOpen, setInfoDialogOpen] = useState(false);
  const [infoDialogData, setInfoDialogData] = useState<{
    type: 'act' | 'sequence' | 'scene' | 'shot';
    node: Act | Sequence | Scene | Shot;
  } | null>(null);

  // =====================================================
  // LOAD DATA - Only if no initialData provided
  // =====================================================

  useEffect(() => {
    // ðŸš€ PERFORMANCE: Skip loading if we already have initialData
    if (!initialData) {
      console.time(`â±ï¸ [PERF] FilmDropdown Full Load: ${projectId}`);
      loadTimelineData();
    } else {
      console.log('[FilmDropdown] ðŸš€ Using cached initialData - INSTANT LOAD!');
      console.log(`â±ï¸ [PERF] FilmDropdown with cache: ${projectId} - 0ms (instant)`);
    }
  }, [projectId, initialData]);

  // Update characters when external characters change
  useEffect(() => {
    if (externalCharacters) {
      console.log('[FilmDropdown] External characters updated:', externalCharacters.length);
      setCharacters(externalCharacters);
    }
  }, [externalCharacters]);

  // ðŸš€ PERFORMANCE: Notify parent of data changes to update cache
  // Use ref to avoid re-triggering the effect on every render
  const onDataChangeRef = useRef(onDataChange);
  useEffect(() => {
    onDataChangeRef.current = onDataChange;
  }, [onDataChange]);

  // Update parent cache whenever data changes (debounced with slight delay)
  useEffect(() => {
    // Always notify parent of current data state
    const timer = setTimeout(() => {
      if (onDataChangeRef.current && !loading) {
        onDataChangeRef.current({
          acts,
          sequences,
          scenes,
          shots,
        });
      }
    }, 100); // Small delay to batch updates

    return () => clearTimeout(timer);
  }, [acts, sequences, scenes, shots, loading]);

  const loadTimelineData = async () => {
    const cacheKey = `timeline:${projectId}`;
    const perfId = `timeline-load-${projectId}`;

    try {
      setLoading(true);
      const token = await getAccessToken();
      if (!token) {
        toast.error('Nicht angemeldet');
        return;
      }

      // ðŸš€ CACHE: Try to load from cache first (Stale-While-Revalidate)
      const cached = cacheManager.get<TimelineData>(cacheKey);
      if (cached.data) {
        console.log(`[FilmDropdown] ðŸ’¾ Loading from cache (${cached.isStale ? 'stale' : 'fresh'})`);
        setActs(cached.data.acts);
        setSequences(cached.data.sequences);
        setScenes(cached.data.scenes);
        setShots(cached.data.shots);
        
        // If fresh, we're done!
        if (!cached.isStale) {
          setLoading(false);
          perfMonitor.end(perfId, 'CACHE_READ', `Timeline Load (cached): ${projectId}`);
          return;
        }
        // If stale, continue loading in background
        console.log('[FilmDropdown] ðŸ”„ Revalidating stale cache in background...');
      }

      perfMonitor.start(perfId);

      // Load Acts (Level 1)
      let loadedActs = await TimelineAPI.getActs(projectId, token);
      
      // If no acts exist, initialize 3-Act structure
      if (!loadedActs || loadedActs.length === 0) {
        console.log('No acts found, initializing 3-act structure...');
        await ShotsAPI.initializeThreeActStructure(projectId, token);
        // Reload acts after initialization
        loadedActs = await TimelineAPI.getActs(projectId, token);
      }
      
      setActs(loadedActs || []);

      // ðŸš€ PERFORMANCE: Load ALL nodes in parallel
      const [allSequences, allScenes, allShots] = await Promise.all([
        TimelineAPI.getAllSequencesByProject(projectId, token).catch(err => {
          console.error('Error loading sequences:', err);
          return Promise.all(
            loadedActs.map(act => 
              TimelineAPI.getSequences(act.id, token).catch(() => [])
            )
          ).then(results => results.flat());
        }),
        
        TimelineAPI.getAllScenesByProject(projectId, token).catch(err => {
          console.error('Error loading scenes:', err);
          return [];
        }),
        
        ShotsAPI.getAllShotsByProject(projectId, token).catch(err => {
          console.error('Error loading shots:', err);
          return [];
        })
      ]);

      setSequences(allSequences || []);
      setScenes(allScenes || []);
      setShots(allShots || []);

      // Load characters for @-mentions in shots (only if not provided by parent)
      if (!externalCharacters) {
        try {
          const projectCharacters = await CharactersAPI.getCharacters(projectId, token);
          console.log('[FilmDropdown] Loaded characters for project:', projectId, projectCharacters);
          setCharacters(projectCharacters || []);
        } catch (error) {
          console.error('[FilmDropdown] Error loading characters:', error);
          setCharacters([]);
        }
      } else {
        console.log('[FilmDropdown] Using characters from parent:', externalCharacters.length);
      }

      // ðŸš€ CACHE: Save to cache
      const timelineData: TimelineData = {
        acts: loadedActs || [],
        sequences: allSequences || [],
        scenes: allScenes || [],
        shots: allShots || [],
      };
      cacheManager.set(cacheKey, timelineData, {
        ttl: 5 * 60 * 1000,      // 5 minutes
        staleTime: 30 * 1000,    // 30 seconds
      });

      perfMonitor.end(perfId, 'TIMELINE_LOAD', `Timeline Load (API): ${projectId}`, {
        acts: loadedActs.length,
        sequences: allSequences.length,
        scenes: allScenes.length,
        shots: allShots.length,
      });

    } catch (error) {
      console.error('Error loading timeline data:', error);
      toast.error('Fehler beim Laden der Timeline-Daten');
      perfMonitor.end(perfId, 'TIMELINE_LOAD', `Timeline Load (ERROR): ${projectId}`);
    } finally {
      setLoading(false);
    }
  };

  // =====================================================
  // ADD HANDLERS
  // =====================================================

  const handleAddAct = async () => {
    if (creating === 'act') return;

    // ðŸ”¥ FIX: Filter out temp acts and calculate correct act number
    const realActs = acts.filter(a => !a.id.startsWith('temp-'));
    const maxActNumber = realActs.reduce((max, a) => Math.max(max, a.actNumber), 0);
    const newActNumber = maxActNumber + 1;
    
    const tempId = `temp-act-${Date.now()}`;
    const optimisticAct: Act = {
      id: tempId,
      projectId,
      actNumber: newActNumber,
      title: `Act ${newActNumber}`,
      description: '',
      orderIndex: realActs.length,
    };

    setActs([...acts, optimisticAct]);
    setExpandedActs(new Set([...expandedActs, tempId]));
    setPendingIds(prev => new Set([...prev, tempId]));
    setCreating('act');

    try {
      const token = await getAccessToken();
      if (!token) {
        setActs(acts.filter(a => a.id !== tempId));
        setPendingIds(prev => {
          const next = new Set(prev);
          next.delete(tempId);
          return next;
        });
        toast.error('Nicht angemeldet');
        setCreating(null);
        return;
      }

      const newAct = await TimelineAPI.createAct(projectId, {
        actNumber: newActNumber,
        title: `Act ${newActNumber}`,
      }, token);

      // ðŸš€ PERFORMANCE: Batch state updates
      setActs(acts => acts.map(a => a.id === tempId ? newAct : a));
      setPendingIds(prev => {
        const next = new Set(prev);
        next.delete(tempId);
        return next;
      });
      
      // ðŸš€ CACHE: Invalidate timeline cache
      cacheManager.invalidate(`timeline:${projectId}`);
      
      // Success toast removed for instant feel - user sees the node appear!
    } catch (error) {
      console.error('Error creating act:', error);
      setActs(acts.filter(a => a.id !== tempId));
      setPendingIds(prev => {
        const next = new Set(prev);
        next.delete(tempId);
        return next;
      });
      toast.error('Fehler beim Erstellen des Acts');
    } finally {
      setCreating(null);
    }
  };

  const handleAddSequence = async (actId: string) => {
    if (creating === `sequence-${actId}`) return;

    // ðŸ”¥ FIX: Filter out temp sequences and calculate correct sequence number
    const actSequences = sequences.filter(s => 
      s && 
      s.actId === actId && 
      !s.id.startsWith('temp-')
    );
    
    // Find max sequence number to avoid duplicates
    const maxSeqNumber = actSequences.reduce((max, s) => Math.max(max, s.sequenceNumber), 0);
    const newSeqNumber = maxSeqNumber + 1;
    
    const tempId = `temp-seq-${Date.now()}`;
    const optimisticSequence: Sequence = {
      id: tempId,
      projectId,
      actId,
      sequenceNumber: newSeqNumber,
      title: `Sequence ${newSeqNumber}`,
      description: '',
      color: '#ECFDF5',
      orderIndex: actSequences.length,
    };

    setSequences([...sequences, optimisticSequence]);
    setExpandedActs(new Set([...expandedActs, actId]));
    setPendingIds(prev => new Set([...prev, tempId]));
    setCreating(`sequence-${actId}`);

    try {
      const token = await getAccessToken();
      if (!token) {
        setSequences(sequences.filter(s => s.id !== tempId));
        setPendingIds(prev => {
          const next = new Set(prev);
          next.delete(tempId);
          return next;
        });
        toast.error('Nicht angemeldet');
        setCreating(null);
        return;
      }

      const newSequence = await TimelineAPI.createSequence(actId, {
        sequenceNumber: newSeqNumber,
        title: `Sequence ${newSeqNumber}`,
        color: '#ECFDF5',
      }, token);

      // ðŸš€ PERFORMANCE: Batch state updates
      setSequences(seqs => seqs.map(s => s.id === tempId ? newSequence : s));
      setPendingIds(prev => {
        const next = new Set(prev);
        next.delete(tempId);
        return next;
      });
      // Success toast removed for instant feel - user sees the node appear!
    } catch (error) {
      console.error('Error creating sequence:', error);
      setSequences(seqs => seqs.filter(s => s.id !== tempId));
      setPendingIds(prev => {
        const next = new Set(prev);
        next.delete(tempId);
        return next;
      });
      toast.error('Fehler beim Erstellen der Sequenz');
    } finally {
      setCreating(null);
    }
  };

  const handleAddScene = async (sequenceId: string) => {
    if (creating === `scene-${sequenceId}`) return;

    // ðŸ”¥ FIX: Filter out temp scenes and calculate correct scene number
    const seqScenes = scenes.filter(s => 
      s && 
      s.sequenceId === sequenceId && 
      !s.id.startsWith('temp-')
    );
    
    // Find max scene number to avoid duplicates
    const maxSceneNumber = seqScenes.reduce((max, s) => Math.max(max, s.sceneNumber), 0);
    const newSceneNumber = maxSceneNumber + 1;
    
    const tempId = `temp-scene-${Date.now()}`;
    const optimisticScene: Scene = {
      id: tempId,
      projectId,
      sequenceId,
      sceneNumber: newSceneNumber,
      title: `Scene ${newSceneNumber}`,
      description: '',
      location: '',
      timeOfDay: 'day',
      characters: [],
      orderIndex: seqScenes.length,
    };

    setScenes([...scenes, optimisticScene]);
    setExpandedSequences(new Set([...expandedSequences, sequenceId]));
    setPendingIds(prev => new Set([...prev, tempId]));
    setCreating(`scene-${sequenceId}`);

    try {
      const token = await getAccessToken();
      if (!token) {
        setScenes(scenes.filter(s => s.id !== tempId));
        setPendingIds(prev => {
          const next = new Set(prev);
          next.delete(tempId);
          return next;
        });
        toast.error('Nicht angemeldet');
        setCreating(null);
        return;
      }

      const newScene = await TimelineAPI.createScene(sequenceId, {
        sceneNumber: newSceneNumber,
        title: `Scene ${newSceneNumber}`,
      }, token);

      // ðŸš€ PERFORMANCE: Batch state updates
      setScenes(scenes => scenes.map(s => s.id === tempId ? newScene : s));
      setPendingIds(prev => {
        const next = new Set(prev);
        next.delete(tempId);
        return next;
      });
      // Success toast removed for instant feel - user sees the node appear!
    } catch (error) {
      console.error('Error creating scene:', error);
      setScenes(scenes => scenes.filter(s => s.id !== tempId));
      setPendingIds(prev => {
        const next = new Set(prev);
        next.delete(tempId);
        return next;
      });
      toast.error('Fehler beim Erstellen der Scene');
    } finally {
      setCreating(null);
    }
  };

  const handleAddShot = async (sceneId: string) => {
    // ðŸš« Block if scene is still pending (temp-ID)
    if (sceneId.startsWith('temp-')) {
      toast.error('Warte bis die Scene erstellt ist');
      return;
    }
    
    if (creating === `shot-${sceneId}`) return;

    // ðŸ”¥ FIX: Filter out temp shots and calculate correct shot number
    const sceneShots = shots.filter(s => 
      s && 
      s.sceneId === sceneId && 
      !s.id.startsWith('temp-')
    );
    
    // Find max shot number to avoid duplicates
    // shotNumber is stored as string like "Shot 1", so we need to extract the number
    const maxShotNumber = sceneShots.reduce((max, s) => {
      const match = s.shotNumber?.match(/\d+/);
      const num = match ? parseInt(match[0], 10) : 0;
      return Math.max(max, num);
    }, 0);
    const newShotNumber = maxShotNumber + 1;
    
    const tempId = `temp-shot-${Date.now()}`;
    const optimisticShot: Shot = {
      id: tempId,
      projectId,
      sceneId,
      shotNumber: `Shot ${newShotNumber}`,
      description: '',
      orderIndex: sceneShots.length,
    };

    setShots([...shots, optimisticShot]);
    setExpandedScenes(new Set([...expandedScenes, sceneId]));
    setPendingIds(prev => new Set([...prev, tempId]));
    setCreating(`shot-${sceneId}`);

    try {
      const token = await getAccessToken();
      if (!token) {
        setShots(shots.filter(s => s.id !== tempId));
        setPendingIds(prev => {
          const next = new Set(prev);
          next.delete(tempId);
          return next;
        });
        toast.error('Nicht angemeldet');
        setCreating(null);
        return;
      }

      const newShot = await ShotsAPI.createShot(sceneId, {
        shotNumber: `Shot ${newShotNumber}`,
        description: '',
      }, token);

      // ðŸš€ PERFORMANCE: Batch state updates
      setShots(shots => shots.map(s => s.id === tempId ? newShot : s));
      setPendingIds(prev => {
        const next = new Set(prev);
        next.delete(tempId);
        return next;
      });
      // Success toast removed for instant feel - user sees the node appear!
    } catch (error) {
      console.error('Error creating shot:', error);
      setShots(shots.filter(s => s.id !== tempId));
      setPendingIds(prev => {
        const next = new Set(prev);
        next.delete(tempId);
        return next;
      });
      toast.error('Fehler beim Erstellen des Shots');
    } finally {
      setCreating(null);
    }
  };

  // =====================================================
  // UPDATE HANDLERS (Inline Editing)
  // =====================================================

  const handleUpdateAct = async (actId: string) => {
    const updates = editValues[actId];
    if (!updates) return;

    try {
      const token = await getAccessToken();
      if (!token) return;

      await TimelineAPI.updateAct(actId, updates, token);
      
      setActs(acts => acts.map(a => 
        a.id === actId ? { ...a, ...updates } : a
      ));
      
      setEditingAct(null);
      setEditValues(prev => {
        const next = { ...prev };
        delete next[actId];
        return next;
      });
      
      toast.success('Act aktualisiert');
    } catch (error) {
      console.error('Error updating act:', error);
      toast.error('Fehler beim Aktualisieren');
    }
  };

  const handleUpdateSequence = async (sequenceId: string) => {
    const updates = editValues[sequenceId];
    if (!updates) return;

    try {
      const token = await getAccessToken();
      if (!token) return;

      await TimelineAPI.updateSequence(sequenceId, updates, token);
      
      setSequences(seqs => seqs.map(s => 
        s.id === sequenceId ? { ...s, ...updates } : s
      ));
      
      setEditingSequence(null);
      setEditValues(prev => {
        const next = { ...prev };
        delete next[sequenceId];
        return next;
      });
      
      toast.success('Sequenz aktualisiert');
    } catch (error) {
      console.error('Error updating sequence:', error);
      toast.error('Fehler beim Aktualisieren');
    }
  };

  const handleUpdateScene = async (sceneId: string) => {
    const updates = editValues[sceneId];
    if (!updates) return;

    try {
      const token = await getAccessToken();
      if (!token) return;

      await TimelineAPI.updateScene(sceneId, updates, token);
      
      setScenes(scenes => scenes.map(s => 
        s.id === sceneId ? { ...s, ...updates } : s
      ));
      
      setEditingScene(null);
      setEditValues(prev => {
        const next = { ...prev };
        delete next[sceneId];
        return next;
      });
      
      toast.success('Szene aktualisiert');
    } catch (error) {
      console.error('Error updating scene:', error);
      toast.error('Fehler beim Aktualisieren');
    }
  };

  // =====================================================
  // DELETE HANDLERS
  // =====================================================

  const handleDeleteAct = async (actId: string) => {
    // Find the act to get its title for confirmation
    const actToDelete = acts.find(a => a.id === actId);
    if (!actToDelete) {
      console.error('[FilmDropdown] Act not found for deletion:', actId);
      toast.error('Act nicht gefunden');
      return;
    }

    console.log('[FilmDropdown] ðŸ—‘ï¸ Deleting act:', {
      id: actId,
      title: actToDelete.title,
      number: actToDelete.actNumber
    });

    if (!confirm(`Act "${actToDelete.title}" und alle untergeordneten Elemente lÃ¶schen?`)) {
      console.log('[FilmDropdown] Deletion cancelled by user');
      return;
    }

    const actSequences = sequences.filter(s => s.actId === actId);
    const sequenceIds = actSequences.map(s => s.id);
    const actScenes = scenes.filter(s => sequenceIds.includes(s.sequenceId));
    const sceneIds = actScenes.map(s => s.id);

    console.log('[FilmDropdown] Deleting act with:', {
      sequences: actSequences.length,
      scenes: actScenes.length,
      sequenceIds,
      sceneIds
    });

    // Optimistic delete
    setActs(prevActs => prevActs.filter(a => a.id !== actId));
    setSequences(seqs => seqs.filter(s => s.actId !== actId));
    setScenes(sc => sc.filter(s => !sequenceIds.includes(s.sequenceId)));
    setShots(sh => sh.filter(s => !sceneIds.includes(s.sceneId)));

    try {
      const token = await getAccessToken();
      if (!token) return;

      console.log('[FilmDropdown] Calling API to delete act:', actId);
      await TimelineAPI.deleteAct(actId, token);
      console.log('[FilmDropdown] âœ… Act deleted successfully');
      
      // Register undo action
      undoManager.push({
        type: 'delete',
        entity: 'act',
        id: actId,
        previousData: {
          act: actToDelete,
          sequences: actSequences,
          scenes: actScenes,
        },
        timestamp: new Date(),
        description: `Act "${actToDelete.title}" gelÃ¶scht`,
      });

      // Register undo callback
      undoManager.registerCallback(`undo:delete:act:${actId}`, {
        execute: async () => {
          // Restore act
          const token = await getAccessToken();
          if (!token) throw new Error('Not authenticated');
          
          // Recreate act
          const newAct = await TimelineAPI.createAct(projectId, {
            actNumber: actToDelete.actNumber,
            title: actToDelete.title,
            description: actToDelete.description,
          }, token);
          
          // Restore to state
          setActs(prevActs => [...prevActs, newAct].sort((a, b) => a.actNumber - b.actNumber));
          
          toast.success(`Act "${actToDelete.title}" wiederhergestellt`);
        },
        description: `Act "${actToDelete.title}" wiederherstellen`,
      });
      
      toast.success('Act gelÃ¶scht (CMD+Z zum RÃ¼ckgÃ¤ngigmachen)');
    } catch (error) {
      console.error('Error deleting act:', error);
      toast.error('Fehler beim LÃ¶schen');
      loadTimelineData(); // Reload on error
    }
  };

  const handleDuplicateAct = async (actId: string) => {
    const actToDuplicate = acts.find(a => a.id === actId);
    if (!actToDuplicate) return;

    try {
      const token = await getAccessToken();
      if (!token) return;

      // Show loading toast
      toast.loading('Act wird dupliziert...');

      // Create new act with duplicated data
      const maxActNumber = acts.reduce((max, a) => Math.max(max, a.actNumber), 0);
      const newAct = await TimelineAPI.createAct(projectId, {
        actNumber: maxActNumber + 1,
        title: `${actToDuplicate.title} (Kopie)`,
        description: actToDuplicate.description,
        color: actToDuplicate.color,
      }, token);

      // Get all sequences in this act
      const actSequences = sequences.filter(s => s.actId === actId);
      
      // ðŸš€ OPTIMISTIC UI: Create ALL temp data INSTANTLY
      const tempSequences = actSequences.map((seq, seqIdx) => ({
        ...seq,
        id: `temp-seq-${Date.now()}-${seqIdx}`,
        actId: newAct.id,
      }));
      
      const tempScenesMap: Record<string, typeof scenes> = {};
      const tempShotsMap: Record<string, typeof shots> = {};
      
      actSequences.forEach((seq, seqIdx) => {
        const seqScenes = scenes.filter(sc => sc.sequenceId === seq.id);
        tempScenesMap[seq.id] = seqScenes.map((sc, scIdx) => ({
          ...sc,
          id: `temp-scene-${Date.now()}-${seqIdx}-${scIdx}`,
          sequenceId: tempSequences[seqIdx].id,
        }));
        
        seqScenes.forEach((sc, scIdx) => {
          const sceneShots = shots.filter(sh => sh.sceneId === sc.id);
          const tempSceneId = tempScenesMap[seq.id][scIdx].id;
          tempShotsMap[sc.id] = sceneShots.map((shot, shotIdx) => ({
            ...shot,
            id: `temp-shot-${Date.now()}-${seqIdx}-${scIdx}-${shotIdx}`,
            sceneId: tempSceneId,
          }));
        });
      });
      
      const allTempScenes = Object.values(tempScenesMap).flat();
      const allTempShots = Object.values(tempShotsMap).flat();
      
      // Show EVERYTHING immediately! User sees instant result ðŸš€
      setActs(prevActs => [...prevActs, newAct]);
      setSequences(prevSequences => [...prevSequences, ...tempSequences]);
      setScenes(prevScenes => [...prevScenes, ...allTempScenes]);
      setShots(prevShots => [...prevShots, ...allTempShots]);
      toast.dismiss();
      toast.success(`Act mit ${tempSequences.length} Sequenzen, ${allTempScenes.length} Szenen und ${allTempShots.length} Shots dupliziert`);
      
      // ðŸš€ PARALLEL: Create everything in background with maximum parallelization
      const sequencePromises = actSequences.map(async (seq, seqIdx) => {
        const newSeq = await TimelineAPI.createSequence(newAct.id, {
          sequenceNumber: seq.sequenceNumber,
          title: seq.title,
          description: seq.description,
          color: seq.color,
        }, token);
        
        const seqScenes = tempScenesMap[seq.id];
        const originalScenes = scenes.filter(sc => sc.sequenceId === seq.id);
        
        // Create ALL scenes in this sequence in PARALLEL
        const scenePromises = originalScenes.map(async (scene, scIdx) => {
          const newScene = await TimelineAPI.createScene(newSeq.id, {
            sceneNumber: scene.sceneNumber,
            title: scene.title,
            description: scene.description,
            location: scene.location,
            timeOfDay: scene.timeOfDay,
            characters: scene.characters,
          }, token);
          
          const originalShots = shots.filter(sh => sh.sceneId === scene.id);
          const tempSceneShots = tempShotsMap[scene.id];
          
          // Create ALL shots for this scene in PARALLEL
          const shotPromises = originalShots.map((shot, shotIdx) =>
            ShotsAPI.createShot(newScene.id, {
              shotNumber: shot.shotNumber,
              description: shot.description,
              cameraAngle: shot.cameraAngle,
              cameraMovement: shot.cameraMovement,
              framing: shot.framing,
              lens: shot.lens,
              duration: shot.duration,
              shotlengthMinutes: shot.shotlengthMinutes,
              shotlengthSeconds: shot.shotlengthSeconds,
              notes: shot.notes,
              dialog: shot.dialog,
            }, token).then(realShot => ({
              tempId: tempSceneShots[shotIdx].id,
              realShot
            }))
          );
          
          const shotResults = await Promise.all(shotPromises);
          
          return {
            tempSceneId: seqScenes[scIdx].id,
            realScene: newScene,
            shotResults
          };
        });
        
        const sceneResults = await Promise.all(scenePromises);
        
        return {
          tempSeqId: tempSequences[seqIdx].id,
          realSeq: newSeq,
          sceneResults
        };
      });
      
      const sequenceResults = await Promise.all(sequencePromises);
      
      // Replace ALL temp data with real data
      setSequences(prevSequences => {
        const updated = [...prevSequences];
        sequenceResults.forEach(({ tempSeqId, realSeq }) => {
          const idx = updated.findIndex(s => s.id === tempSeqId);
          if (idx >= 0) updated[idx] = realSeq;
        });
        return updated;
      });
      
      setScenes(prevScenes => {
        const updated = [...prevScenes];
        sequenceResults.forEach(({ sceneResults }) => {
          sceneResults.forEach(({ tempSceneId, realScene }) => {
            const idx = updated.findIndex(s => s.id === tempSceneId);
            if (idx >= 0) updated[idx] = realScene;
          });
        });
        return updated;
      });
      
      setShots(prevShots => {
        const updated = [...prevShots];
        sequenceResults.forEach(({ sceneResults }) => {
          sceneResults.forEach(({ shotResults }) => {
            shotResults.forEach(({ tempId, realShot }) => {
              const idx = updated.findIndex(s => s.id === tempId);
              if (idx >= 0) updated[idx] = realShot;
            });
          });
        });
        return updated;
      });
    } catch (error) {
      console.error('Error duplicating act:', error);
      toast.dismiss();
      toast.error('Fehler beim Duplizieren');
    }
  };

  const handleDuplicateSequence = async (sequenceId: string) => {
    const sequenceToDuplicate = sequences.find(s => s.id === sequenceId);
    if (!sequenceToDuplicate) return;

    try {
      const token = await getAccessToken();
      if (!token) return;

      // Show loading toast
      toast.loading('Sequenz wird dupliziert...');

      // Create new sequence with duplicated data
      const actSequences = sequences.filter(s => s.actId === sequenceToDuplicate.actId);
      const maxSeqNumber = actSequences.reduce((max, s) => Math.max(max, s.sequenceNumber), 0);
      const newSequence = await TimelineAPI.createSequence(sequenceToDuplicate.actId, {
        sequenceNumber: maxSeqNumber + 1,
        title: `${sequenceToDuplicate.title} (Kopie)`,
        description: sequenceToDuplicate.description,
        color: sequenceToDuplicate.color,
      }, token);

      // Get all scenes in this sequence
      const seqScenes = scenes.filter(sc => sc.sequenceId === sequenceId);
      
      // ðŸš€ OPTIMISTIC UI: Create temp data instantly
      const tempScenes = seqScenes.map((sc, idx) => ({
        ...sc,
        id: `temp-scene-${Date.now()}-${idx}`,
        sequenceId: newSequence.id,
      }));
      
      const tempShotsMap: Record<string, typeof shots> = {};
      seqScenes.forEach((sc, idx) => {
        const sceneShots = shots.filter(sh => sh.sceneId === sc.id);
        tempShotsMap[sc.id] = sceneShots.map((shot, shotIdx) => ({
          ...shot,
          id: `temp-shot-${Date.now()}-${idx}-${shotIdx}`,
          sceneId: tempScenes[idx].id,
        }));
      });
      
      const allTempShots = Object.values(tempShotsMap).flat();
      
      // Show everything immediately!
      setSequences(prevSequences => [...prevSequences, newSequence]);
      setScenes(prevScenes => [...prevScenes, ...tempScenes]);
      setShots(prevShots => [...prevShots, ...allTempShots]);
      toast.dismiss();
      toast.success(`Sequenz mit ${tempScenes.length} Szenen und ${allTempShots.length} Shots dupliziert`);
      
      // ðŸš€ PARALLEL: Create scenes and shots in background
      const scenePromises = seqScenes.map(async (scene, sceneIdx) => {
        const newScene = await TimelineAPI.createScene(newSequence.id, {
          sceneNumber: scene.sceneNumber,
          title: scene.title,
          description: scene.description,
          location: scene.location,
          timeOfDay: scene.timeOfDay,
          characters: scene.characters,
        }, token);
        
        const sceneShots = tempShotsMap[scene.id];
        const originalShots = shots.filter(sh => sh.sceneId === scene.id);
        
        // Create ALL shots for this scene in PARALLEL
        const shotPromises = originalShots.map((shot, shotIdx) => 
          ShotsAPI.createShot(newScene.id, {
            shotNumber: shot.shotNumber,
            description: shot.description,
            cameraAngle: shot.cameraAngle,
            cameraMovement: shot.cameraMovement,
            framing: shot.framing,
            lens: shot.lens,
            duration: shot.duration,
            shotlengthMinutes: shot.shotlengthMinutes,
            shotlengthSeconds: shot.shotlengthSeconds,
            notes: shot.notes,
            dialog: shot.dialog,
          }, token).then(realShot => ({
            tempId: sceneShots[shotIdx].id,
            realShot
          }))
        );
        
        const shotResults = await Promise.all(shotPromises);
        
        return {
          tempSceneId: tempScenes[sceneIdx].id,
          realScene: newScene,
          shotResults
        };
      });
      
      const sceneResults = await Promise.all(scenePromises);
      
      // Replace temp data with real data
      setScenes(prevScenes => {
        const updated = [...prevScenes];
        sceneResults.forEach(({ tempSceneId, realScene }) => {
          const idx = updated.findIndex(s => s.id === tempSceneId);
          if (idx >= 0) updated[idx] = realScene;
        });
        return updated;
      });
      
      setShots(prevShots => {
        const updated = [...prevShots];
        sceneResults.forEach(({ shotResults }) => {
          shotResults.forEach(({ tempId, realShot }) => {
            const idx = updated.findIndex(s => s.id === tempId);
            if (idx >= 0) updated[idx] = realShot;
          });
        });
        return updated;
      });
    } catch (error) {
      console.error('Error duplicating sequence:', error);
      toast.dismiss();
      toast.error('Fehler beim Duplizieren');
    }
  };

  const handleDuplicateScene = async (sceneId: string) => {
    const sceneToDuplicate = scenes.find(s => s.id === sceneId);
    if (!sceneToDuplicate) return;

    try {
      const token = await getAccessToken();
      if (!token) return;

      // Show loading toast
      toast.loading('Scene wird dupliziert...');

      // Create new scene with duplicated data
      const seqScenes = scenes.filter(s => s.sequenceId === sceneToDuplicate.sequenceId);
      const maxSceneNumber = seqScenes.reduce((max, s) => Math.max(max, s.sceneNumber), 0);
      const newScene = await TimelineAPI.createScene(sceneToDuplicate.sequenceId, {
        sceneNumber: maxSceneNumber + 1,
        title: `${sceneToDuplicate.title} (Kopie)`,
        description: sceneToDuplicate.description,
        location: sceneToDuplicate.location,
        timeOfDay: sceneToDuplicate.timeOfDay,
        characters: sceneToDuplicate.characters,
      }, token);

      // Get all shots in this scene
      const sceneShots = shots.filter(sh => sh.sceneId === sceneId);
      
      // ðŸš€ PERFORMANCE: Create temp shots for instant UI update
      const tempShots = sceneShots.map((shot, idx) => ({
        ...shot,
        id: `temp-shot-${Date.now()}-${idx}`,
        sceneId: newScene.id,
      }));
      
      // Show shots immediately (optimistic UI)
      setScenes(prevScenes => [...prevScenes, newScene]);
      setShots(prevShots => [...prevShots, ...tempShots]);
      toast.dismiss();
      toast.success(`Scene mit ${tempShots.length} Shots dupliziert`);
      
      // ðŸš€ PERFORMANCE: Create ALL shots in PARALLEL (not serial!)
      const shotPromises = sceneShots.map((shot, idx) => 
        ShotsAPI.createShot(newScene.id, {
          shotNumber: shot.shotNumber,
          description: shot.description,
          cameraAngle: shot.cameraAngle,
          cameraMovement: shot.cameraMovement,
          framing: shot.framing,
          lens: shot.lens,
          duration: shot.duration,
          shotlengthMinutes: shot.shotlengthMinutes,
          shotlengthSeconds: shot.shotlengthSeconds,
          notes: shot.notes,
          dialog: shot.dialog,
        }, token).then(realShot => ({ tempId: tempShots[idx].id, realShot }))
      );
      
      // Wait for all shots to be created
      const shotResults = await Promise.all(shotPromises);
      
      // Replace temp shots with real shots
      setShots(prevShots => {
        const updated = [...prevShots];
        shotResults.forEach(({ tempId, realShot }) => {
          const tempIdx = updated.findIndex(s => s.id === tempId);
          if (tempIdx >= 0) {
            updated[tempIdx] = realShot;
          }
        });
        return updated;
      });


    } catch (error) {
      console.error('Error duplicating scene:', error);
      toast.dismiss();
      toast.error('Fehler beim Duplizieren');
    }
  };

  const handleDeleteSequence = async (sequenceId: string) => {
    if (!confirm('Sequenz und alle Szenen lÃ¶schen?')) return;

    const seqScenes = scenes.filter(s => s.sequenceId === sequenceId);
    const sceneIds = seqScenes.map(s => s.id);

    // Optimistic delete
    setSequences(seqs => seqs.filter(s => s.id !== sequenceId));
    setScenes(sc => sc.filter(s => s.sequenceId !== sequenceId));
    setShots(sh => sh.filter(s => !sceneIds.includes(s.sceneId)));

    try {
      const token = await getAccessToken();
      if (!token) return;

      await TimelineAPI.deleteSequence(sequenceId, token);
      
      // ðŸš€ CACHE: Invalidate timeline cache
      cacheManager.invalidate(`timeline:${projectId}`);
      
      toast.success('Sequenz gelÃ¶scht');
    } catch (error) {
      console.error('Error deleting sequence:', error);
      toast.error('Fehler beim LÃ¶schen');
      loadTimelineData();
    }
  };

  const handleDeleteScene = async (sceneId: string) => {
    if (!confirm('Scene und alle Shots lÃ¶schen?')) return;

    // Optimistic delete - ðŸ”¥ FIX: Use functional updates to prevent stale state
    setScenes(prevScenes => prevScenes.filter(s => s.id !== sceneId));
    setShots(prevShots => prevShots.filter(s => s.sceneId !== sceneId));

    try {
      const token = await getAccessToken();
      if (!token) return;

      await TimelineAPI.deleteScene(sceneId, token);
      
      // ðŸš€ CACHE: Invalidate timeline cache
      cacheManager.invalidate(`timeline:${projectId}`);
      
      toast.success('Scene gelÃ¶scht');
    } catch (error) {
      console.error('Error deleting scene:', error);
      toast.error('Fehler beim LÃ¶schen');
      loadTimelineData();
    }
  };

  const handleDeleteShot = async (shotId: string) => {
    // Optimistic delete - ðŸ”¥ FIX: Use functional updates to prevent stale state
    setShots(prevShots => prevShots.filter(s => s.id !== shotId));

    try {
      const token = await getAccessToken();
      if (!token) return;

      await ShotsAPI.deleteShot(shotId, token);
      toast.success('Shot gelÃ¶scht');
    } catch (error) {
      console.error('Error deleting shot:', error);
      toast.error('Fehler beim LÃ¶schen');
      loadTimelineData();
    }
  };

  // =====================================================
  // DRAG & DROP HANDLERS
  // =====================================================

  // ACTS - EinfÃ¼gen an Index (Drop Zone)
  const handleActDropAtIndex = (draggedId: string, targetIndex: number) => {
    const draggedIndex = acts.findIndex(a => a.id === draggedId);
    if (draggedIndex === -1) return;

    const adjustedTargetIndex = draggedIndex < targetIndex ? targetIndex - 1 : targetIndex;

    const reordered = [...acts];
    const [removed] = reordered.splice(draggedIndex, 1);
    reordered.splice(adjustedTargetIndex, 0, removed);

    // Optimistic Update - SOFORT!
    setActs(reordered);

    // Backend async
    (async () => {
      try {
        const token = await getAccessToken();
        if (token) {
          const actIds = reordered.map(a => a.id);
          await TimelineAPI.reorderNodes(actIds, token);
        }
      } catch (error) {
        console.error('Error reordering acts:', error);
        toast.error('Fehler beim Sortieren');
        loadTimelineData();
      }
    })();
  };

  // ACTS - Platz tauschen (Drop auf Item)
  const handleActSwap = (draggedId: string, targetId: string) => {
    const draggedIndex = acts.findIndex(a => a.id === draggedId);
    const targetIndex = acts.findIndex(a => a.id === targetId);

    if (draggedIndex === -1 || targetIndex === -1) return;

    const reordered = [...acts];
    const [removed] = reordered.splice(draggedIndex, 1);
    reordered.splice(targetIndex, 0, removed);

    // Optimistic Update - SOFORT!
    setActs(reordered);

    // Backend async
    (async () => {
      try {
        const token = await getAccessToken();
        if (token) {
          const actIds = reordered.map(a => a.id);
          await TimelineAPI.reorderNodes(actIds, token);
        }
      } catch (error) {
        console.error('Error swapping acts:', error);
        toast.error('Fehler beim Tauschen');
        loadTimelineData();
      }
    })();
  };

  // SEQUENCES - EinfÃ¼gen an Index
  const handleSequenceDropAtIndex = (draggedId: string, targetIndex: number, actId: string) => {
    const draggedSeq = sequences.find(s => s.id === draggedId);
    if (!draggedSeq || draggedSeq.actId !== actId) return;

    const actSequences = sequences.filter(s => s.actId === actId);
    const draggedIndex = actSequences.findIndex(s => s.id === draggedId);
    if (draggedIndex === -1) return;

    const adjustedTargetIndex = draggedIndex < targetIndex ? targetIndex - 1 : targetIndex;

    const reordered = [...actSequences];
    const [removed] = reordered.splice(draggedIndex, 1);
    reordered.splice(adjustedTargetIndex, 0, removed);

    const otherSequences = sequences.filter(s => s.actId !== actId);
    
    // Optimistic Update - SOFORT!
    setSequences([...otherSequences, ...reordered]);

    // Backend async
    (async () => {
      try {
        const token = await getAccessToken();
        if (token) {
          const seqIds = reordered.map(s => s.id);
          await TimelineAPI.reorderNodes(seqIds, token);
        }
      } catch (error) {
        console.error('Error reordering sequences:', error);
        toast.error('Fehler beim Sortieren');
        loadTimelineData();
      }
    })();
  };

  // SEQUENCES - Platz tauschen
  const handleSequenceSwap = (draggedId: string, targetId: string) => {
    const draggedSeq = sequences.find(s => s.id === draggedId);
    const targetSeq = sequences.find(s => s.id === targetId);
    
    if (!draggedSeq || !targetSeq || draggedSeq.actId !== targetSeq.actId) return;

    const actSequences = sequences.filter(s => s.actId === draggedSeq.actId);
    const draggedIndex = actSequences.findIndex(s => s.id === draggedId);
    const targetIndex = actSequences.findIndex(s => s.id === targetId);

    if (draggedIndex === -1 || targetIndex === -1) return;

    const reordered = [...actSequences];
    const [removed] = reordered.splice(draggedIndex, 1);
    reordered.splice(targetIndex, 0, removed);

    const otherSequences = sequences.filter(s => s.actId !== draggedSeq.actId);
    
    // Optimistic Update - SOFORT!
    setSequences([...otherSequences, ...reordered]);

    // Backend async
    (async () => {
      try {
        const token = await getAccessToken();
        if (token) {
          const seqIds = reordered.map(s => s.id);
          await TimelineAPI.reorderNodes(seqIds, token);
        }
      } catch (error) {
        console.error('Error swapping sequences:', error);
        toast.error('Fehler beim Tauschen');
        loadTimelineData();
      }
    })();
  };

  // SCENES - EinfÃ¼gen an Index
  const handleSceneDropAtIndex = (draggedId: string, targetIndex: number, sequenceId: string) => {
    const draggedScene = scenes.find(s => s.id === draggedId);
    if (!draggedScene || draggedScene.sequenceId !== sequenceId) return;

    const seqScenes = scenes.filter(s => s.sequenceId === sequenceId);
    const draggedIndex = seqScenes.findIndex(s => s.id === draggedId);
    if (draggedIndex === -1) return;

    const adjustedTargetIndex = draggedIndex < targetIndex ? targetIndex - 1 : targetIndex;

    const reordered = [...seqScenes];
    const [removed] = reordered.splice(draggedIndex, 1);
    reordered.splice(adjustedTargetIndex, 0, removed);

    const otherScenes = scenes.filter(s => s.sequenceId !== sequenceId);
    
    // Optimistic Update - SOFORT!
    setScenes([...otherScenes, ...reordered]);

    // Backend async
    (async () => {
      try {
        const token = await getAccessToken();
        if (token) {
          const sceneIds = reordered.map(s => s.id);
          await TimelineAPI.reorderNodes(sceneIds, token);
        }
      } catch (error) {
        console.error('Error reordering scenes:', error);
        toast.error('Fehler beim Sortieren');
        loadTimelineData();
      }
    })();
  };

  // SCENES - Platz tauschen
  const handleSceneSwap = (draggedId: string, targetId: string) => {
    const draggedScene = scenes.find(s => s.id === draggedId);
    const targetScene = scenes.find(s => s.id === targetId);
    
    if (!draggedScene || !targetScene || draggedScene.sequenceId !== targetScene.sequenceId) return;

    const seqScenes = scenes.filter(s => s.sequenceId === draggedScene.sequenceId);
    const draggedIndex = seqScenes.findIndex(s => s.id === draggedId);
    const targetIndex = seqScenes.findIndex(s => s.id === targetId);

    if (draggedIndex === -1 || targetIndex === -1) return;

    const reordered = [...seqScenes];
    const [removed] = reordered.splice(draggedIndex, 1);
    reordered.splice(targetIndex, 0, removed);

    const otherScenes = scenes.filter(s => s.sequenceId !== draggedScene.sequenceId);
    
    // Optimistic Update - SOFORT!
    setScenes([...otherScenes, ...reordered]);

    // Backend async
    (async () => {
      try {
        const token = await getAccessToken();
        if (token) {
          const sceneIds = reordered.map(s => s.id);
          await TimelineAPI.reorderNodes(sceneIds, token);
        }
      } catch (error) {
        console.error('Error swapping scenes:', error);
        toast.error('Fehler beim Tauschen');
        loadTimelineData();
      }
    })();
  };

  // =====================================================
  // CROSS-CONTAINER DRAG & DROP
  // =====================================================

  const handleSceneMoveToSequence = async (sceneId: string, targetSequenceId: string) => {
    const scene = scenes.find(s => s.id === sceneId);
    if (!scene || scene.sequenceId === targetSequenceId) return;

    console.log('ðŸ”„ Moving scene to new sequence:', { sceneId, targetSequenceId });

    // Optimistic update
    setScenes(scenes => scenes.map(s => 
      s.id === sceneId ? { ...s, sequenceId: targetSequenceId } : s
    ));

    try {
      const token = await getAccessToken();
      if (!token) {
        toast.error('Nicht angemeldet');
        loadTimelineData();
        return;
      }

      await TimelineAPI.updateScene(sceneId, { 
        sequenceId: targetSequenceId 
      }, token);
      
      toast.success('Szene verschoben');
    } catch (error) {
      console.error('Error moving scene:', error);
      toast.error('Fehler beim Verschieben');
      loadTimelineData();
    }
  };

  const handleShotMoveToScene = async (shotId: string, targetSceneId: string) => {
    const shot = shots.find(s => s.id === shotId);
    if (!shot || shot.sceneId === targetSceneId) return;

    console.log('ðŸ”„ Moving shot to new scene:', { shotId, targetSceneId });

    // Optimistic update
    setShots(shots => shots.map(s => 
      s.id === shotId ? { ...s, sceneId: targetSceneId } : s
    ));

    try {
      const token = await getAccessToken();
      if (!token) {
        toast.error('Nicht angemeldet');
        loadTimelineData();
        return;
      }

      await ShotsAPI.updateShot(shotId, { 
        sceneId: targetSceneId 
      }, token);
      
      toast.success('Shot verschoben');
    } catch (error) {
      console.error('Error moving shot:', error);
      toast.error('Fehler beim Verschieben');
      loadTimelineData();
    }
  };

  // =====================================================
  // SHOT HANDLERS
  // =====================================================

  const handleUpdateShot = async (shotId: string, updates: Partial<Shot>) => {
    // Optimistic update
    setShots(shots => shots.map(s => 
      s.id === shotId ? { ...s, ...updates } : s
    ));

    try {
      const token = await getAccessToken();
      if (!token) return;

      await ShotsAPI.updateShot(shotId, updates, token);
      toast.success('Shot aktualisiert');
    } catch (error) {
      console.error('Error updating shot:', error);
      toast.error('Fehler beim Aktualisieren');
      loadTimelineData();
    }
  };

  const handleDuplicateShot = async (shotId: string) => {
    const shot = shots.find(s => s.id === shotId);
    if (!shot) return;

    try {
      const token = await getAccessToken();
      if (!token) return;

      const sceneShots = shots.filter(s => s.sceneId === shot.sceneId && !s.id.startsWith('temp-'));
      
      // Extract numeric part from shotNumber strings like "Shot 1", "Shot 2"
      const shotNumbers = sceneShots.map(s => {
        const match = String(s.shotNumber).match(/\d+/);
        return match ? parseInt(match[0]) : 0;
      });
      const maxShotNumber = Math.max(0, ...shotNumbers);
      
      const newShot = await ShotsAPI.createShot(shot.sceneId, {
        shotNumber: `${shot.shotNumber} (Kopie)`,
        description: shot.description,
        cameraAngle: shot.cameraAngle,
        cameraMovement: shot.cameraMovement,
        framing: shot.framing,
        lens: shot.lens,
        duration: shot.duration,
        shotlengthMinutes: shot.shotlengthMinutes,
        shotlengthSeconds: shot.shotlengthSeconds,
        notes: shot.notes,
        dialog: shot.dialog,
      }, token);

      setShots([...shots, newShot]);
      toast.success('Shot dupliziert');
    } catch (error) {
      console.error('Error duplicating shot:', error);
      toast.error('Fehler beim Duplizieren');
    }
  };

  // SHOTS - EinfÃ¼gen an Index
  const handleShotDropAtIndex = (draggedId: string, targetIndex: number, sceneId: string) => {
    const draggedShot = shots.find(s => s.id === draggedId);
    if (!draggedShot || draggedShot.sceneId !== sceneId) return;

    const sceneShots = shots.filter(s => s.sceneId === sceneId);
    const draggedIndex = sceneShots.findIndex(s => s.id === draggedId);
    if (draggedIndex === -1) return;

    const adjustedTargetIndex = draggedIndex < targetIndex ? targetIndex - 1 : targetIndex;

    const reordered = [...sceneShots];
    const [removed] = reordered.splice(draggedIndex, 1);
    reordered.splice(adjustedTargetIndex, 0, removed);

    const otherShots = shots.filter(s => s.sceneId !== sceneId);
    
    // Optimistic Update - SOFORT!
    setShots([...otherShots, ...reordered]);

    // Backend async
    (async () => {
      try {
        const token = await getAccessToken();
        if (token) {
          const shotIds = reordered.map(s => s.id);
          await ShotsAPI.reorderShots(sceneId, shotIds, token);
        }
      } catch (error) {
        console.error('Error reordering shots:', error);
        toast.error('Fehler beim Sortieren');
        loadTimelineData();
      }
    })();
  };

  // SHOTS - Platz tauschen
  const handleShotSwap = (draggedId: string, targetId: string) => {
    const draggedShot = shots.find(s => s.id === draggedId);
    const targetShot = shots.find(s => s.id === targetId);
    
    if (!draggedShot || !targetShot || draggedShot.sceneId !== targetShot.sceneId) return;

    const sceneShots = shots.filter(s => s.sceneId === draggedShot.sceneId);
    const draggedIndex = sceneShots.findIndex(s => s.id === draggedId);
    const targetIndex = sceneShots.findIndex(s => s.id === targetId);

    if (draggedIndex === -1 || targetIndex === -1) return;

    const reordered = [...sceneShots];
    const [removed] = reordered.splice(draggedIndex, 1);
    reordered.splice(targetIndex, 0, removed);

    const otherShots = shots.filter(s => s.sceneId !== draggedShot.sceneId);
    
    // Optimistic Update - SOFORT!
    setShots([...otherShots, ...reordered]);

    // Backend async
    (async () => {
      try {
        const token = await getAccessToken();
        if (token) {
          const shotIds = reordered.map(s => s.id);
          await ShotsAPI.reorderShots(draggedShot.sceneId, shotIds, token);
        }
      } catch (error) {
        console.error('Error swapping shots:', error);
        toast.error('Fehler beim Tauschen');
        loadTimelineData();
      }
    })();
  };

  const handleShotImageUpload = async (shotId: string, file: File) => {
    // Check file size (max 5MB per backend limit)
    const maxSizeMB = 5;
    const maxSizeBytes = maxSizeMB * 1024 * 1024;
    
    if (file.size > maxSizeBytes) {
      const fileSizeMB = (file.size / (1024 * 1024)).toFixed(2);
      toast.error(`Bild zu groÃŸ: ${fileSizeMB} MB (Max: ${maxSizeMB} MB)`);
      return;
    }

    // Optimistic UI: Zeige Preview sofort
    const previewUrl = URL.createObjectURL(file);
    setShots(shots => shots.map(s => 
      s.id === shotId ? { ...s, imageUrl: previewUrl } : s
    ));

    // Toast mit Loading-Anzeige
    toast.loading('Bild wird hochgeladen...');

    try {
      const token = await getAccessToken();
      if (!token) {
        toast.dismiss();
        toast.error('Nicht authentifiziert');
        URL.revokeObjectURL(previewUrl);
        setShots(shots => shots.map(s => 
          s.id === shotId ? { ...s, imageUrl: undefined } : s
        ));
        return;
      }

      const imageUrl = await ShotsAPI.uploadShotImage(shotId, file, token);
      
      // Cleanup temporary URL
      URL.revokeObjectURL(previewUrl);
      
      // Update mit echter URL
      setShots(shots => shots.map(s => 
        s.id === shotId ? { ...s, imageUrl } : s
      ));
      
      toast.dismiss();
      toast.success('Bild hochgeladen! âœ…');
    } catch (error) {
      console.error('âŒ Error uploading shot image:', error);
      
      // Revert optimistic update
      URL.revokeObjectURL(previewUrl);
      setShots(shots => shots.map(s => 
        s.id === shotId ? { ...s, imageUrl: undefined } : s
      ));
      
      toast.dismiss();
      toast.error(`Fehler beim Hochladen: ${error instanceof Error ? error.message : 'Unbekannter Fehler'}`);
    }
  };

  const handleShotAudioUpload = async (
    shotId: string, 
    file: File, 
    type: 'music' | 'sfx', 
    label?: string,
    startTime?: number,
    endTime?: number,
    fadeIn?: number,
    fadeOut?: number
  ) => {
    try {
      const token = await getAccessToken();
      if (!token) return;

      await ShotsAPI.uploadShotAudio(shotId, file, type, token, label, startTime, endTime, fadeIn, fadeOut);
      
      // Reload shot data to get new audio
      const updatedShot = await ShotsAPI.getShot(shotId, token);
      setShots(shots => shots.map(s => s.id === shotId ? updatedShot : s));
      
      toast.success('Audio hochgeladen');
    } catch (error) {
      console.error('Error uploading shot audio:', error);
      toast.error('Fehler beim Hochladen');
    }
  };

  const handleShotAudioDelete = async (audioId: string) => {
    try {
      const token = await getAccessToken();
      if (!token) return;

      await ShotsAPI.deleteShotAudio(audioId, token);
      
      // Remove audio from local state
      setShots(shots => shots.map(shot => ({
        ...shot,
        audioFiles: shot.audioFiles?.filter(a => a.id !== audioId)
      })));
      
      toast.success('Audio gelÃ¶scht');
    } catch (error) {
      console.error('Error deleting shot audio:', error);
      toast.error('Fehler beim LÃ¶schen');
    }
  };

  const handleShotAudioUpdate = async (
    audioId: string, 
    updates: { 
      label?: string; 
      startTime?: number; 
      endTime?: number; 
      fadeIn?: number; 
      fadeOut?: number 
    }
  ) => {
    try {
      const token = await getAccessToken();
      if (!token) return;

      await ShotsAPI.updateShotAudio(audioId, updates, token);
      
      // Update audio in local state
      setShots(shots => shots.map(shot => ({
        ...shot,
        audioFiles: shot.audioFiles?.map(a => 
          a.id === audioId ? { ...a, ...updates } : a
        )
      })));
      
      toast.success('Audio aktualisiert');
    } catch (error) {
      console.error('Error updating shot audio:', error);
      toast.error('Fehler beim Aktualisieren');
    }
  };

  const handleShotCharacterAdd = async (shotId: string, characterId: string) => {
    const shot = shots.find(s => s.id === shotId);
    if (!shot) return;

    const currentCharacters = shot.characters || [];
    if (currentCharacters.some(c => c.id === characterId)) {
      toast.error('Character bereits hinzugefÃ¼gt');
      return;
    }

    // Find character data for optimistic update
    const character = characters.find(c => c.id === characterId);
    if (!character) {
      toast.error('Character nicht gefunden');
      return;
    }

    const optimisticCharacters = [...currentCharacters, character];

    // Optimistic update
    setShots(shots => shots.map(s => 
      s.id === shotId ? { ...s, characters: optimisticCharacters } : s
    ));

    try {
      const token = await getAccessToken();
      if (!token) {
        // Rollback
        setShots(shots => shots.map(s => 
          s.id === shotId ? { ...s, characters: currentCharacters } : s
        ));
        toast.error('Nicht angemeldet');
        return;
      }

      // Use the new dedicated API endpoint
      const updatedShot = await ShotsAPI.addCharacterToShot(shotId, characterId, token);
      
      // Update with real data from server
      setShots(shots => shots.map(s => 
        s.id === shotId ? { ...s, characters: updatedShot.characters } : s
      ));
      
      toast.success('Character hinzugefÃ¼gt');
    } catch (error) {
      console.error('Error adding character to shot:', error);
      toast.error('Fehler beim HinzufÃ¼gen');
      // Rollback
      setShots(shots => shots.map(s => 
        s.id === shotId ? { ...s, characters: currentCharacters } : s
      ));
    }
  };

  const handleShotCharacterRemove = async (shotId: string, characterId: string) => {
    const shot = shots.find(s => s.id === shotId);
    if (!shot) return;

    const currentCharacters = shot.characters || [];
    const updatedCharacters = currentCharacters.filter(c => c.id !== characterId);

    // Optimistic update
    setShots(shots => shots.map(s => 
      s.id === shotId ? { ...s, characters: updatedCharacters } : s
    ));

    try {
      const token = await getAccessToken();
      if (!token) {
        // Rollback
        setShots(shots => shots.map(s => 
          s.id === shotId ? { ...s, characters: currentCharacters } : s
        ));
        toast.error('Nicht angemeldet');
        return;
      }

      // Use the dedicated API endpoint
      await ShotsAPI.removeCharacterFromShot(shotId, characterId, token);
      
      toast.success('Character entfernt');
    } catch (error) {
      console.error('Error removing character from shot:', error);
      toast.error('Fehler beim Entfernen');
      // Rollback
      setShots(shots => shots.map(s => 
        s.id === shotId ? { ...s, characters: currentCharacters } : s
      ));
    }
  };

  // =====================================================
  // RENDER
  // =====================================================

  if (loading) {
    return (
      <div className="flex items-center justify-center py-12">
        <div className="text-muted-foreground">Dropdown wird geladen...</div>
      </div>
    );
  }

  return (
    <DndProvider backend={HTML5Backend}>
      <div ref={containerRef} data-beat-container className="flex flex-col gap-1.5 p-4">
        {/* Add Act Button */}
        <Button
          size="sm"
          variant="outline"
          onClick={handleAddAct}
          disabled={creating === 'act'}
          className="w-1/2 md:w-1/4 ml-auto bg-white text-center border-2 border-dashed border-blue-200 dark:border-blue-700 text-blue-600 dark:text-blue-400 hover:bg-blue-50 dark:hover:bg-blue-950/40"
        >
          <Plus className="size-3.5 mr-1.5" />
          Act hinzufÃ¼gen
        </Button>

        {/* Acts mit Drop Zones */}
        {acts.map((act, actIndex) => {
          const actSequences = sequences.filter(s => s.actId === act.id);
          const isExpanded = expandedActs.has(act.id);
          const isEditing = editingAct === act.id;
          const isPending = pendingIds.has(act.id);

          return (
            <div key={act.id}>
              {/* Drop Zone VOR diesem Act */}
              <DropZone
                type={ItemTypes.ACT}
                index={actIndex}
                onDrop={handleActDropAtIndex}
                label="Act"
                height="act"
              />
              
              {/* Act selbst (droppable fÃ¼r Swap) */}
              <DraggableAct
                act={act}
                index={actIndex}
                onSwap={handleActSwap}
              >
                <Collapsible
                  open={isExpanded}
                  onOpenChange={(open) => {
                    const next = new Set(expandedActs);
                    if (open) {
                      next.add(act.id);
                    } else {
                      next.delete(act.id);
                    }
                    setExpandedActs(next);
                  }}
                >
                  <div 
                    data-act-card
                    data-act-id={act.id}
                    className={cn(
                      "border-2 rounded-lg bg-blue-50 border-blue-200 dark:bg-blue-950/40 dark:border-blue-700 overflow-hidden",
                      isPending && "opacity-90 animate-pulse"
                    )}
                  >
                    {/* Act Header */}
                  <div 
                    data-act-header
                    data-act-header-id={act.id}
                    className="flex items-center gap-2 py-4 px-3"
                  >
                    <GripVertical className="size-4 text-muted-foreground cursor-move flex-shrink-0" />
                    
                    <CollapsibleTrigger asChild>
                      <button className="flex-shrink-0">
                        {isExpanded ? (
                          <ChevronDown className="size-4" />
                        ) : (
                          <ChevronRight className="size-4" />
                        )}
                      </button>
                    </CollapsibleTrigger>

                  {isEditing ? (
                    <>
                      <Input
                        value={editValues[act.id]?.title ?? act.title}
                        onChange={(e) => setEditValues(prev => ({
                          ...prev,
                          [act.id]: { ...prev[act.id], title: e.target.value }
                        }))}
                        className="h-7 flex-1 bg-white text-[18px] border-blue-200 dark:border-blue-700 focus:border-blue-400 dark:focus:border-blue-500 focus-visible:ring-blue-400/20"
                        placeholder="Titel"
                      />
                      <Button
                        size="sm"
                        variant="ghost"
                        onClick={() => handleUpdateAct(act.id)}
                        className="h-7 px-2"
                      >
                        Speichern
                      </Button>
                    </>
                  ) : (
                    <>
                      <span 
                        className="flex-1 font-semibold text-[18px] text-[rgb(21,93,252)] cursor-pointer hover:opacity-80 transition-opacity"
                        onClick={() => {
                          const next = new Set(expandedActs);
                          if (isExpanded) {
                            next.delete(act.id);
                          } else {
                            next.add(act.id);
                          }
                          setExpandedActs(next);
                        }}
                      >
                        {act.title}
                      </span>
                      <DropdownMenu>
                        <DropdownMenuTrigger asChild>
                          <Button
                            size="sm"
                            variant="ghost"
                            className="h-7 px-2"
                            onClick={(e) => e.stopPropagation()}
                          >
                            <MoreVertical className="size-3.5" />
                          </Button>
                        </DropdownMenuTrigger>
                        <DropdownMenuContent align="end">
                          <DropdownMenuItem 
                            onClick={() => {
                              setInfoDialogData({ type: 'act', node: act });
                              setInfoDialogOpen(true);
                            }}
                          >
                            <Info className="size-3.5 mr-2" />
                            Informationen
                          </DropdownMenuItem>
                          <DropdownMenuItem 
                            onClick={() => {
                              setEditingAct(act.id);
                              setEditValues(prev => ({
                                ...prev,
                                [act.id]: { title: act.title, description: act.description }
                              }));
                            }}
                          >
                            <Edit className="size-3.5 mr-2" />
                            Edit Act
                          </DropdownMenuItem>
                          <DropdownMenuItem onClick={() => handleDuplicateAct(act.id)}>
                            <Copy className="size-3.5 mr-2" />
                            Duplicate Act
                          </DropdownMenuItem>
                          <DropdownMenuItem 
                            onClick={() => handleDeleteAct(act.id)}
                            className="text-red-600 focus:text-red-600"
                          >
                            <Trash2 className="size-3.5 mr-2" />
                            Delete Act
                          </DropdownMenuItem>
                        </DropdownMenuContent>
                      </DropdownMenu>
                    </>
                  )}
                </div>

                <CollapsibleContent>
                  {/* Act Description */}
                  <div className="px-3 pb-2 space-y-2">
                    {isEditing ? (
                      <Textarea
                        value={editValues[act.id]?.description ?? act.description ?? ''}
                        onChange={(e) => setEditValues(prev => ({
                          ...prev,
                          [act.id]: { ...prev[act.id], description: e.target.value }
                        }))}
                        className="bg-white text-sm border-blue-200 dark:border-blue-700 focus:border-blue-400 dark:focus:border-blue-500 focus-visible:ring-blue-400/20"
                        placeholder="Beschreibung"
                        rows={2}
                      />
                    ) : (
                      <div
                        onClick={() => {
                          setEditingAct(act.id);
                          setEditValues(prev => ({
                            ...prev,
                            [act.id]: { title: act.title, description: act.description }
                          }));
                        }}
                        className="text-sm text-[rgb(21,93,252)] cursor-pointer hover:text-foreground transition-colors min-h-[2rem] flex items-center"
                      >
                        {act.description || '+ Beschreibung'}
                      </div>
                    )}
                  </div>

                  {/* Sequences */}
                  <div className="px-3 pb-3 flex flex-col gap-1">
                    <Button
                      size="sm"
                      variant="outline"
                      onClick={() => handleAddSequence(act.id)}
                      disabled={creating === `sequence-${act.id}`}
                      className="w-1/2 md:w-1/4 ml-auto h-7 text-xs bg-white text-center border-2 border-dashed border-green-200 dark:border-green-700 text-green-600 dark:text-green-400 hover:bg-green-50 dark:hover:bg-green-950/40"
                    >
                      <Plus className="size-3 mr-1" />
                      Sequenz hinzufÃ¼gen
                    </Button>

                    {actSequences.map((sequence, seqIndex) => {
                      const seqScenes = scenes.filter(s => s.sequenceId === sequence.id);
                      const isSeqExpanded = expandedSequences.has(sequence.id);
                      const isSeqEditing = editingSequence === sequence.id;
                      const isSeqPending = pendingIds.has(sequence.id);

                      return (
                        <div key={sequence.id}>
                          {/* Drop Zone VOR dieser Sequence */}
                          <DropZone
                            type={ItemTypes.SEQUENCE}
                            index={seqIndex}
                            onDrop={(draggedId, targetIndex) => handleSequenceDropAtIndex(draggedId, targetIndex, act.id)}
                            label="Sequence"
                            height="sequence"
                          />
                          
                          {/* Sequence selbst (droppable fÃ¼r Swap) */}
                          <DraggableSequence
                            sequence={sequence}
                            index={seqIndex}
                            onSwap={handleSequenceSwap}
                          >
                            <Collapsible
                              open={isSeqExpanded}
                              onOpenChange={(open) => {
                                const next = new Set(expandedSequences);
                                if (open) {
                                  next.add(sequence.id);
                                } else {
                                  next.delete(sequence.id);
                                }
                                setExpandedSequences(next);
                              }}
                            >
                              <div 
                                data-sequence-id={sequence.id}
                                className={cn(
                                  "border-2 rounded-lg bg-green-50 border-green-200 dark:bg-green-950/40 dark:border-green-700 overflow-hidden",
                                  isSeqPending && "opacity-90 animate-pulse"
                                )}
                              >
                                {/* Sequence Header */}
                              <div className="flex items-center gap-2 p-2">
                                <GripVertical className="size-3 text-muted-foreground cursor-move flex-shrink-0" />
                                
                                <CollapsibleTrigger asChild>
                                  <button className="flex-shrink-0">
                                    {isSeqExpanded ? (
                                      <ChevronDown className="size-3.5" />
                                    ) : (
                                      <ChevronRight className="size-3.5" />
                                    )}
                                  </button>
                                </CollapsibleTrigger>

                              {isSeqEditing ? (
                                <>
                                  <Input
                                    value={editValues[sequence.id]?.title ?? sequence.title}
                                    onChange={(e) => setEditValues(prev => ({
                                      ...prev,
                                      [sequence.id]: { ...prev[sequence.id], title: e.target.value }
                                    }))}
                                    className="h-6 flex-1 bg-white text-sm border-green-200 dark:border-green-700 focus:border-green-400 dark:focus:border-green-500 focus-visible:ring-green-400/20"
                                    placeholder="Titel"
                                  />
                                  <Button
                                    size="sm"
                                    variant="ghost"
                                    onClick={() => handleUpdateSequence(sequence.id)}
                                    className="h-6 px-2 text-xs"
                                  >
                                    Speichern
                                  </Button>
                                </>
                              ) : (
                                <>
                                  <span 
                                    className="flex-1 text-sm font-semibold text-[14px] text-[rgb(0,166,62)] cursor-pointer hover:opacity-80 transition-opacity"
                                    onClick={() => {
                                      const next = new Set(expandedSequences);
                                      if (isSeqExpanded) {
                                        next.delete(sequence.id);
                                      } else {
                                        next.add(sequence.id);
                                      }
                                      setExpandedSequences(next);
                                    }}
                                  >
                                    {sequence.title}
                                  </span>
                                  <DropdownMenu>
                                    <DropdownMenuTrigger asChild>
                                      <Button
                                        size="sm"
                                        variant="ghost"
                                        className="h-6 px-2"
                                        onClick={(e) => e.stopPropagation()}
                                      >
                                        <MoreVertical className="size-3" />
                                      </Button>
                                    </DropdownMenuTrigger>
                                    <DropdownMenuContent align="end">
                                      <DropdownMenuItem 
                                        onClick={() => {
                                          setInfoDialogData({ type: 'sequence', node: sequence });
                                          setInfoDialogOpen(true);
                                        }}
                                      >
                                        <Info className="size-3 mr-2" />
                                        Informationen
                                      </DropdownMenuItem>
                                      <DropdownMenuItem 
                                        onClick={() => {
                                          setEditingSequence(sequence.id);
                                          setEditValues(prev => ({
                                            ...prev,
                                            [sequence.id]: { title: sequence.title, description: sequence.description }
                                          }));
                                        }}
                                      >
                                        <Edit className="size-3 mr-2" />
                                        Edit Sequence
                                      </DropdownMenuItem>
                                      <DropdownMenuItem onClick={() => handleDuplicateSequence(sequence.id)}>
                                        <Copy className="size-3 mr-2" />
                                        Duplicate Sequence
                                      </DropdownMenuItem>
                                      <DropdownMenuItem 
                                        onClick={() => handleDeleteSequence(sequence.id)}
                                        className="text-red-600 focus:text-red-600"
                                      >
                                        <Trash2 className="size-3 mr-2" />
                                        Delete Sequence
                                      </DropdownMenuItem>
                                    </DropdownMenuContent>
                                  </DropdownMenu>
                                </>
                              )}
                            </div>

                            <CollapsibleContent>
                              {/* Sequence Description */}
                              <div className="px-2 pb-2 space-y-2">
                                {isSeqEditing ? (
                                  <Textarea
                                    value={editValues[sequence.id]?.description ?? sequence.description ?? ''}
                                    onChange={(e) => setEditValues(prev => ({
                                      ...prev,
                                      [sequence.id]: { ...prev[sequence.id], description: e.target.value }
                                    }))}
                                    className="bg-white text-xs border-green-200 dark:border-green-700 focus:border-green-400 dark:focus:border-green-500 focus-visible:ring-green-400/20"
                                    placeholder="Beschreibung"
                                    rows={2}
                                  />
                                ) : (
                                  <div
                                    onClick={() => {
                                      setEditingSequence(sequence.id);
                                      setEditValues(prev => ({
                                        ...prev,
                                        [sequence.id]: { title: sequence.title, description: sequence.description }
                                      }));
                                    }}
                                    className="text-xs text-[rgb(0,166,62)] cursor-pointer hover:text-foreground transition-colors min-h-[1.5rem] flex items-center"
                                  >
                                    {sequence.description || '+ Beschreibung'}
                                  </div>
                                )}
                              </div>

                              {/* Scenes */}
                              <div className="px-2 pb-2 flex flex-col gap-1">
                                <Button
                                  size="sm"
                                  variant="outline"
                                  onClick={() => handleAddScene(sequence.id)}
                                  disabled={creating === `scene-${sequence.id}`}
                                  className="w-1/2 md:w-1/4 ml-auto h-6 text-xs bg-white text-center border-2 border-dashed border-pink-200 dark:border-pink-700 text-pink-600 dark:text-pink-400 hover:bg-pink-50 dark:hover:bg-pink-950/40"
                                >
                                  <Plus className="size-3 mr-1" />
                                  Scene hinzufÃ¼gen
                                </Button>

                                {seqScenes.map((scene, sceneIndex) => {
                                  const sceneShots = shots.filter(s => s.sceneId === scene.id);
                                  const isSceneExpanded = expandedScenes.has(scene.id);
                                  const isSceneEditing = editingScene === scene.id;
                                  const isScenePending = pendingIds.has(scene.id);

                                  return (
                                    <div key={scene.id}>
                                      {/* Drop Zone VOR dieser Scene */}
                                      <DropZone
                                        type={ItemTypes.SCENE}
                                        index={sceneIndex}
                                        onDrop={(draggedId, targetIndex) => handleSceneDropAtIndex(draggedId, targetIndex, sequence.id)}
                                        label="Scene"
                                        height="scene"
                                      />
                                      
                                      {/* Scene selbst (droppable fÃ¼r Swap) */}
                                      <DraggableScene
                                        scene={scene}
                                        index={sceneIndex}
                                        onSwap={handleSceneSwap}
                                      >
                                        <Collapsible
                                          open={isSceneExpanded}
                                          onOpenChange={(open) => {
                                            const next = new Set(expandedScenes);
                                            if (open) {
                                              next.add(scene.id);
                                            } else {
                                              next.delete(scene.id);
                                            }
                                            setExpandedScenes(next);
                                          }}
                                        >
                                          <div 
                                            data-scene-id={scene.id}
                                            className={cn(
                                              "border-2 rounded-lg bg-pink-50 border-pink-200 dark:bg-pink-950/40 dark:border-pink-700 overflow-hidden",
                                              isScenePending && "opacity-90 animate-pulse"
                                            )}
                                          >
                                            {/* Scene Header */}
                                            <div className="flex items-center gap-2 p-2">
                                              <GripVertical className="size-3 text-muted-foreground cursor-move flex-shrink-0" />
                                              
                                              <CollapsibleTrigger asChild>
                                                <button className="flex-shrink-0">
                                                  {isSceneExpanded ? (
                                                    <ChevronDown className="size-3.5" />
                                                  ) : (
                                                    <ChevronRight className="size-3.5" />
                                                  )}
                                                </button>
                                              </CollapsibleTrigger>

                                          {isSceneEditing ? (
                                            <>
                                              <Input
                                                value={editValues[scene.id]?.title ?? scene.title}
                                                onChange={(e) => setEditValues(prev => ({
                                                  ...prev,
                                                  [scene.id]: { ...prev[scene.id], title: e.target.value }
                                                }))}
                                                className="h-6 flex-1 bg-white text-xs border-pink-200 dark:border-pink-700 focus:border-pink-400 dark:focus:border-pink-500 focus-visible:ring-pink-400/20"
                                                placeholder="Titel"
                                              />
                                              <Button
                                                size="sm"
                                                variant="ghost"
                                                onClick={() => handleUpdateScene(scene.id)}
                                                className="h-6 px-2 text-xs"
                                              >
                                                Speichern
                                              </Button>
                                            </>
                                          ) : (
                                            <>
                                              <span 
                                                className="flex-1 text-xs font-semibold text-[14px] text-[rgb(230,0,118)] cursor-pointer hover:opacity-80 transition-opacity"
                                                onClick={() => {
                                                  const next = new Set(expandedScenes);
                                                  if (isSceneExpanded) {
                                                    next.delete(scene.id);
                                                  } else {
                                                    next.add(scene.id);
                                                  }
                                                  setExpandedScenes(next);
                                                }}
                                              >
                                                {scene.title}
                                              </span>
                                              <DropdownMenu>
                                                <DropdownMenuTrigger asChild>
                                                  <Button
                                                    size="sm"
                                                    variant="ghost"
                                                    className="h-6 px-1.5"
                                                    onClick={(e) => e.stopPropagation()}
                                                  >
                                                    <MoreVertical className="size-3" />
                                                  </Button>
                                                </DropdownMenuTrigger>
                                                <DropdownMenuContent align="end">
                                                  <DropdownMenuItem 
                                                    onClick={() => {
                                                      setInfoDialogData({ type: 'scene', node: scene });
                                                      setInfoDialogOpen(true);
                                                    }}
                                                  >
                                                    <Info className="size-3 mr-2" />
                                                    Informationen
                                                  </DropdownMenuItem>
                                                  <DropdownMenuItem 
                                                    onClick={() => {
                                                      setEditingScene(scene.id);
                                                      setEditValues(prev => ({
                                                        ...prev,
                                                        [scene.id]: { title: scene.title, description: scene.description }
                                                      }));
                                                    }}
                                                  >
                                                    <Edit className="size-3 mr-2" />
                                                    Edit Scene
                                                  </DropdownMenuItem>
                                                  <DropdownMenuItem onClick={() => handleDuplicateScene(scene.id)}>
                                                    <Copy className="size-3 mr-2" />
                                                    Duplicate Scene
                                                  </DropdownMenuItem>
                                                  <DropdownMenuItem 
                                                    onClick={() => handleDeleteScene(scene.id)}
                                                    className="text-red-600 focus:text-red-600"
                                                  >
                                                    <Trash2 className="size-3 mr-2" />
                                                    Delete Scene
                                                  </DropdownMenuItem>
                                                </DropdownMenuContent>
                                              </DropdownMenu>
                                            </>
                                          )}
                                        </div>

                                        <CollapsibleContent>
                                          {/* Scene Description */}
                                          <div className="px-2 pb-2 space-y-2">
                                            {isSceneEditing ? (
                                              <Textarea
                                                value={editValues[scene.id]?.description ?? scene.description ?? ''}
                                                onChange={(e) => setEditValues(prev => ({
                                                  ...prev,
                                                  [scene.id]: { ...prev[scene.id], description: e.target.value }
                                                }))}
                                                className="bg-white text-xs border-pink-200 dark:border-pink-700 focus:border-pink-400 dark:focus:border-pink-500 focus-visible:ring-pink-400/20"
                                                placeholder="Beschreibung"
                                                rows={2}
                                              />
                                            ) : (
                                              <div
                                                onClick={() => {
                                                  setEditingScene(scene.id);
                                                  setEditValues(prev => ({
                                                    ...prev,
                                                    [scene.id]: { title: scene.title, description: scene.description }
                                                  }));
                                                }}
                                                className="text-xs text-[rgb(230,0,118)] cursor-pointer hover:text-foreground transition-colors min-h-[1.5rem] flex items-center"
                                              >
                                                {scene.description || '+ Beschreibung'}
                                              </div>
                                            )}
                                          </div>

                                          {/* Shots */}
                                          <div className="px-2 pb-2 flex flex-col gap-1">
                                            <Button
                                              size="sm"
                                              variant="outline"
                                              onClick={() => handleAddShot(scene.id)}
                                              disabled={creating === `shot-${scene.id}` || scene.id.startsWith('temp-') || pendingIds.has(scene.id)}
                                              className="w-1/2 md:w-1/4 ml-auto h-6 text-xs bg-white text-center border-2 border-dashed border-yellow-400 dark:border-yellow-600 text-yellow-600 dark:text-yellow-400 hover:bg-yellow-50 dark:hover:bg-yellow-900/20"
                                            >
                                              <Plus className="size-3 mr-1" />
                                              Shot hinzufÃ¼gen
                                            </Button>

                                            {sceneShots.map((shot, shotIndex) => {
                                              const isShotPending = pendingIds.has(shot.id);
                                              
                                              return (
                                                <div key={shot.id}>
                                                  {/* Drop Zone VOR diesem Shot */}
                                                  <DropZone
                                                    type={ItemTypes.SHOT}
                                                    index={shotIndex}
                                                    onDrop={(draggedId, targetIndex) => handleShotDropAtIndex(draggedId, targetIndex, scene.id)}
                                                    label="Shot"
                                                    height="shot"
                                                  />
                                                  
                                                  {/* Shot selbst (droppable fÃ¼r Swap) */}
                                                  <DraggableShot
                                                    shot={shot}
                                                    index={shotIndex}
                                                    onSwap={handleShotSwap}
                                                  >
                                                    <ShotCard
                                                    shot={shot}
                                                    sceneId={scene.id}
                                                    projectId={projectId}
                                                    isPending={isShotPending}
                                                  projectCharacters={characters}
                                                  isExpanded={expandedShots.has(shot.id)}
                                                  onToggleExpand={() => {
                                                    const next = new Set(expandedShots);
                                                    if (expandedShots.has(shot.id)) {
                                                      next.delete(shot.id);
                                                    } else {
                                                      next.add(shot.id);
                                                    }
                                                    setExpandedShots(next);
                                                  }}
                                                  onUpdate={handleUpdateShot}
                                                  onDelete={handleDeleteShot}
                                                  onDuplicate={handleDuplicateShot}
                                                  onShowInfo={(shotId) => {
                                                    const shotData = shots.find(s => s.id === shotId);
                                                    if (shotData) {
                                                      setInfoDialogData({ type: 'shot', node: shotData });
                                                      setInfoDialogOpen(true);
                                                    }
                                                  }}
                                                  onImageUpload={handleShotImageUpload}
                                                  onAudioUpload={handleShotAudioUpload}
                                                  onAudioDelete={handleShotAudioDelete}
                                                  onAudioUpdate={handleShotAudioUpdate}
                                                  onCharacterAdd={handleShotCharacterAdd}
                                                  onCharacterRemove={handleShotCharacterRemove}
                                                />
                                              </DraggableShot>
                                              
                                              {/* Drop Zone NACH diesem Shot (nur beim letzten) */}
                                              {shotIndex === sceneShots.length - 1 && (
                                                <DropZone
                                                  type={ItemTypes.SHOT}
                                                  index={sceneShots.length}
                                                  onDrop={(draggedId, targetIndex) => handleShotDropAtIndex(draggedId, targetIndex, scene.id)}
                                                  label="Shot"
                                                  height="shot"
                                                />
                                              )}
                                              </div>
                                            );
                                            })}
                                          </div>
                                        </CollapsibleContent>
                                      </div>
                                    </Collapsible>
                                    </DraggableScene>
                                    
                                    {/* Drop Zone NACH dieser Scene (nur beim letzten) */}
                                    {sceneIndex === seqScenes.length - 1 && (
                                      <DropZone
                                        type={ItemTypes.SCENE}
                                        index={seqScenes.length}
                                        onDrop={(draggedId, targetIndex) => handleSceneDropAtIndex(draggedId, targetIndex, sequence.id)}
                                        label="Scene"
                                        height="scene"
                                      />
                                    )}
                                  </div>
                                  );
                                })}
                              </div>
                            </CollapsibleContent>
                          </div>
                        </Collapsible>
                        </DraggableSequence>
                        
                        {/* Drop Zone NACH dieser Sequence (nur beim letzten) */}
                        {seqIndex === actSequences.length - 1 && (
                          <DropZone
                            type={ItemTypes.SEQUENCE}
                            index={actSequences.length}
                            onDrop={(draggedId, targetIndex) => handleSequenceDropAtIndex(draggedId, targetIndex, act.id)}
                            label="Sequence"
                            height="sequence"
                          />
                        )}
                      </div>
                      );
                    })}
                  </div>
                </CollapsibleContent>
              </div>
            </Collapsible>
            </DraggableAct>
            
            {/* Drop Zone NACH diesem Act (nur beim letzten) */}
            {actIndex === acts.length - 1 && (
              <DropZone
                type={ItemTypes.ACT}
                index={acts.length}
                onDrop={handleActDropAtIndex}
                label="Act"
                height="act"
              />
            )}
          </div>
          );
        })}
      </div>

      {/* Statistics & Logs Dialog */}
      {infoDialogData && (
        <TimelineNodeStatsDialog
          open={infoDialogOpen}
          onOpenChange={setInfoDialogOpen}
          nodeType={infoDialogData.type}
          node={infoDialogData.node}
          projectId={projectId}
          projectType={projectType}
        />
      )}
    </DndProvider>
  );
}
